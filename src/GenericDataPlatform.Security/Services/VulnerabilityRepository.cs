using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using GenericDataPlatform.Security.Models;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace GenericDataPlatform.Security.Services
{
    /// <summary>
    /// Repository for storing and retrieving vulnerability information
    /// </summary>
    public class VulnerabilityRepository : IVulnerabilityRepository
    {
        private readonly SecurityOptions _options;
        private readonly ILogger<VulnerabilityRepository> _logger;
        private readonly string _dataDirectory;

        public VulnerabilityRepository(IOptions<SecurityOptions> options, ILogger<VulnerabilityRepository> logger)
        {
            _options = options.Value;
            _logger = logger;
            
            // Create data directory if it doesn't exist
            _dataDirectory = _options.DataDirectory ?? Path.Combine(AppContext.BaseDirectory, "SecurityData");
            Directory.CreateDirectory(_dataDirectory);
            Directory.CreateDirectory(Path.Combine(_dataDirectory, "Vulnerabilities"));
            Directory.CreateDirectory(Path.Combine(_dataDirectory, "ScanResults"));
        }

        /// <summary>
        /// Gets vulnerabilities for a dependency
        /// </summary>
        public async Task<List<VulnerabilityInfo>> GetVulnerabilitiesForDependencyAsync(string dependencyName, string dependencyVersion)
        {
            try
            {
                var vulnerabilities = new List<VulnerabilityInfo>();
                
                // Check if vulnerability data exists
                var filePath = Path.Combine(_dataDirectory, "Vulnerabilities", $"{dependencyName}.json");
                if (!File.Exists(filePath))
                {
                    return vulnerabilities;
                }
                
                // Read vulnerability data
                var json = await File.ReadAllTextAsync(filePath);
                var allVulnerabilities = JsonSerializer.Deserialize<List<VulnerabilityInfo>>(json);
                
                // Filter vulnerabilities for the specific version
                if (allVulnerabilities != null)
                {
                    vulnerabilities = allVulnerabilities
                        .Where(v => v.DependencyName == dependencyName && IsVersionAffected(dependencyVersion, v.AffectedVersions))
                        .ToList();
                }
                
                return vulnerabilities;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting vulnerabilities for dependency {DependencyName} {DependencyVersion}",
                    dependencyName, dependencyVersion);
                return new List<VulnerabilityInfo>();
            }
        }

        /// <summary>
        /// Saves a vulnerability
        /// </summary>
        public async Task SaveVulnerabilityAsync(VulnerabilityInfo vulnerability)
        {
            try
            {
                // Check if vulnerability data exists
                var filePath = Path.Combine(_dataDirectory, "Vulnerabilities", $"{vulnerability.DependencyName}.json");
                List<VulnerabilityInfo> vulnerabilities;
                
                if (File.Exists(filePath))
                {
                    // Read existing vulnerabilities
                    var json = await File.ReadAllTextAsync(filePath);
                    vulnerabilities = JsonSerializer.Deserialize<List<VulnerabilityInfo>>(json) ?? new List<VulnerabilityInfo>();
                    
                    // Remove existing vulnerability with the same ID
                    vulnerabilities.RemoveAll(v => v.Id == vulnerability.Id);
                }
                else
                {
                    vulnerabilities = new List<VulnerabilityInfo>();
                }
                
                // Add new vulnerability
                vulnerabilities.Add(vulnerability);
                
                // Save vulnerabilities
                var options = new JsonSerializerOptions { WriteIndented = true };
                await File.WriteAllTextAsync(filePath, JsonSerializer.Serialize(vulnerabilities, options));
                
                _logger.LogInformation("Saved vulnerability {VulnerabilityId} for dependency {DependencyName}",
                    vulnerability.Id, vulnerability.DependencyName);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error saving vulnerability {VulnerabilityId} for dependency {DependencyName}",
                    vulnerability.Id, vulnerability.DependencyName);
                throw;
            }
        }

        /// <summary>
        /// Saves a scan result
        /// </summary>
        public async Task SaveScanResultAsync(SecurityScanResult scanResult)
        {
            try
            {
                // Generate file name based on project path
                var projectName = Path.GetFileNameWithoutExtension(scanResult.ProjectPath);
                var timestamp = DateTime.UtcNow.ToString("yyyyMMddHHmmss");
                var fileName = $"{projectName}_{timestamp}.json";
                var filePath = Path.Combine(_dataDirectory, "ScanResults", fileName);
                
                // Save scan result
                var options = new JsonSerializerOptions { WriteIndented = true };
                await File.WriteAllTextAsync(filePath, JsonSerializer.Serialize(scanResult, options));
                
                _logger.LogInformation("Saved scan result for project {ProjectPath}", scanResult.ProjectPath);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error saving scan result for project {ProjectPath}", scanResult.ProjectPath);
                throw;
            }
        }

        /// <summary>
        /// Gets the latest scan result for a project
        /// </summary>
        public async Task<SecurityScanResult> GetLatestScanResultAsync(string projectPath)
        {
            try
            {
                var projectName = Path.GetFileNameWithoutExtension(projectPath);
                var directory = new DirectoryInfo(Path.Combine(_dataDirectory, "ScanResults"));
                
                // Get all scan result files for the project
                var files = directory.GetFiles($"{projectName}_*.json")
                    .OrderByDescending(f => f.CreationTimeUtc)
                    .ToList();
                
                if (files.Count == 0)
                {
                    return null;
                }
                
                // Read the latest scan result
                var json = await File.ReadAllTextAsync(files[0].FullName);
                return JsonSerializer.Deserialize<SecurityScanResult>(json);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting latest scan result for project {ProjectPath}", projectPath);
                return null;
            }
        }

        /// <summary>
        /// Gets all scan results for a project
        /// </summary>
        public async Task<List<SecurityScanResult>> GetScanHistoryAsync(string projectPath, int limit = 10)
        {
            try
            {
                var projectName = Path.GetFileNameWithoutExtension(projectPath);
                var directory = new DirectoryInfo(Path.Combine(_dataDirectory, "ScanResults"));
                
                // Get all scan result files for the project
                var files = directory.GetFiles($"{projectName}_*.json")
                    .OrderByDescending(f => f.CreationTimeUtc)
                    .Take(limit)
                    .ToList();
                
                var results = new List<SecurityScanResult>();
                
                foreach (var file in files)
                {
                    var json = await File.ReadAllTextAsync(file.FullName);
                    var result = JsonSerializer.Deserialize<SecurityScanResult>(json);
                    if (result != null)
                    {
                        results.Add(result);
                    }
                }
                
                return results;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting scan history for project {ProjectPath}", projectPath);
                return new List<SecurityScanResult>();
            }
        }

        /// <summary>
        /// Checks if a version is affected by a vulnerability
        /// </summary>
        private bool IsVersionAffected(string version, List<string> affectedVersions)
        {
            if (affectedVersions == null || affectedVersions.Count == 0)
            {
                return false;
            }
            
            // Simple version matching for now
            // In a real implementation, this would use semantic versioning rules
            return affectedVersions.Contains(version) || affectedVersions.Contains("*");
        }
    }

    /// <summary>
    /// Interface for vulnerability repository
    /// </summary>
    public interface IVulnerabilityRepository
    {
        Task<List<VulnerabilityInfo>> GetVulnerabilitiesForDependencyAsync(string dependencyName, string dependencyVersion);
        Task SaveVulnerabilityAsync(VulnerabilityInfo vulnerability);
        Task SaveScanResultAsync(SecurityScanResult scanResult);
        Task<SecurityScanResult> GetLatestScanResultAsync(string projectPath);
        Task<List<SecurityScanResult>> GetScanHistoryAsync(string projectPath, int limit = 10);
    }
}
