using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using Dapper;
using GenericDataPlatform.Common.Resilience;
using GenericDataPlatform.Security.Models;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Polly;

namespace GenericDataPlatform.Security.Services
{
    /// <summary>
    /// SQL Server implementation of the vulnerability repository
    /// </summary>
    public class DatabaseVulnerabilityRepository : IVulnerabilityRepository
    {
        private readonly string _connectionString;
        private readonly ILogger<DatabaseVulnerabilityRepository> _logger;
        private readonly IAsyncPolicy _resiliencePolicy;
        private readonly JsonSerializerOptions _jsonOptions;

        public DatabaseVulnerabilityRepository(
            IOptions<SecurityOptions> options,
            ILogger<DatabaseVulnerabilityRepository> logger,
            IAsyncPolicy resiliencePolicy)
        {
            _connectionString = options.Value.ConnectionStrings?.SqlServer 
                ?? throw new ArgumentNullException(nameof(options.Value.ConnectionStrings.SqlServer), 
                    "SQL Server connection string is required for DatabaseVulnerabilityRepository");
            _logger = logger;
            _resiliencePolicy = resiliencePolicy;
            
            _jsonOptions = new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                WriteIndented = true
            };
            
            // Ensure database tables exist
            EnsureTablesExistAsync().GetAwaiter().GetResult();
        }

        private async Task EnsureTablesExistAsync()
        {
            try
            {
                await _resiliencePolicy.ExecuteAsync(async () =>
                {
                    using var connection = new SqlConnection(_connectionString);
                    await connection.OpenAsync();

                    // Check if Vulnerabilities table exists
                    var tableExists = await connection.ExecuteScalarAsync<int>(
                        "SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Vulnerabilities'");

                    if (tableExists == 0)
                    {
                        _logger.LogInformation("Creating vulnerability tables");
                        
                        // Create Vulnerabilities table
                        var createVulnerabilitiesTable = @"
                            CREATE TABLE Vulnerabilities (
                                Id NVARCHAR(100) PRIMARY KEY,
                                DependencyName NVARCHAR(200) NOT NULL,
                                DependencyVersion NVARCHAR(50) NULL,
                                AffectedVersions NVARCHAR(MAX) NULL,
                                Title NVARCHAR(200) NOT NULL,
                                Description NVARCHAR(MAX) NULL,
                                Severity NVARCHAR(50) NOT NULL,
                                CVSS FLOAT NULL,
                                CveId NVARCHAR(50) NULL,
                                PublishedAt DATETIME2 NULL,
                                DiscoveredAt DATETIME2 NOT NULL,
                                RemedialAction NVARCHAR(MAX) NULL,
                                References NVARCHAR(MAX) NULL,
                                AdditionalData NVARCHAR(MAX) NULL
                            )";
                        
                        await connection.ExecuteAsync(createVulnerabilitiesTable);
                        
                        // Create index on DependencyName
                        await connection.ExecuteAsync(
                            "CREATE INDEX IX_Vulnerabilities_DependencyName ON Vulnerabilities(DependencyName)");
                        
                        // Create SecurityScans table
                        var createSecurityScansTable = @"
                            CREATE TABLE SecurityScans (
                                Id NVARCHAR(100) PRIMARY KEY,
                                ProjectPath NVARCHAR(500) NOT NULL,
                                ScanType NVARCHAR(50) NOT NULL,
                                ScanDate DATETIME2 NOT NULL,
                                VulnerabilityCount INT NOT NULL,
                                CriticalCount INT NOT NULL,
                                HighCount INT NOT NULL,
                                MediumCount INT NOT NULL,
                                LowCount INT NOT NULL,
                                ScanData NVARCHAR(MAX) NOT NULL
                            )";
                        
                        await connection.ExecuteAsync(createSecurityScansTable);
                        
                        // Create index on ProjectPath
                        await connection.ExecuteAsync(
                            "CREATE INDEX IX_SecurityScans_ProjectPath ON SecurityScans(ProjectPath)");
                        
                        // Create index on ScanDate
                        await connection.ExecuteAsync(
                            "CREATE INDEX IX_SecurityScans_ScanDate ON SecurityScans(ScanDate)");
                        
                        _logger.LogInformation("Vulnerability tables created successfully");
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error ensuring vulnerability tables exist");
                throw;
            }
        }

        /// <summary>
        /// Gets vulnerabilities for a dependency
        /// </summary>
        public async Task<List<VulnerabilityInfo>> GetVulnerabilitiesForDependencyAsync(string dependencyName, string dependencyVersion)
        {
            try
            {
                return await _resiliencePolicy.ExecuteAsync(async () =>
                {
                    using var connection = new SqlConnection(_connectionString);
                    await connection.OpenAsync();
                    
                    var sql = @"
                        SELECT * 
                        FROM Vulnerabilities 
                        WHERE DependencyName = @DependencyName";
                    
                    var vulnerabilities = await connection.QueryAsync<VulnerabilityDto>(sql, new { DependencyName = dependencyName });
                    
                    // Map to domain model and filter by version
                    return vulnerabilities
                        .Select(MapToVulnerabilityInfo)
                        .Where(v => IsVersionAffected(dependencyVersion, v.AffectedVersions))
                        .ToList();
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting vulnerabilities for dependency {DependencyName} {DependencyVersion}",
                    dependencyName, dependencyVersion);
                return new List<VulnerabilityInfo>();
            }
        }

        /// <summary>
        /// Saves a vulnerability
        /// </summary>
        public async Task SaveVulnerabilityAsync(VulnerabilityInfo vulnerability)
        {
            try
            {
                await _resiliencePolicy.ExecuteAsync(async () =>
                {
                    using var connection = new SqlConnection(_connectionString);
                    await connection.OpenAsync();
                    
                    // Ensure ID is set
                    if (string.IsNullOrEmpty(vulnerability.Id))
                    {
                        vulnerability.Id = Guid.NewGuid().ToString();
                    }
                    
                    var sql = @"
                        MERGE INTO Vulnerabilities WITH (HOLDLOCK) AS target
                        USING (SELECT @Id AS Id) AS source
                        ON target.Id = source.Id
                        WHEN MATCHED THEN
                            UPDATE SET 
                                DependencyName = @DependencyName,
                                DependencyVersion = @DependencyVersion,
                                AffectedVersions = @AffectedVersions,
                                Title = @Title,
                                Description = @Description,
                                Severity = @Severity,
                                CVSS = @CVSS,
                                CveId = @CveId,
                                PublishedAt = @PublishedAt,
                                DiscoveredAt = @DiscoveredAt,
                                RemedialAction = @RemedialAction,
                                References = @References,
                                AdditionalData = @AdditionalData
                        WHEN NOT MATCHED THEN
                            INSERT (
                                Id, DependencyName, DependencyVersion, AffectedVersions, 
                                Title, Description, Severity, CVSS, CveId, PublishedAt, 
                                DiscoveredAt, RemedialAction, References, AdditionalData
                            )
                            VALUES (
                                @Id, @DependencyName, @DependencyVersion, @AffectedVersions,
                                @Title, @Description, @Severity, @CVSS, @CveId, @PublishedAt,
                                @DiscoveredAt, @RemedialAction, @References, @AdditionalData
                            );";
                    
                    var parameters = new
                    {
                        vulnerability.Id,
                        vulnerability.DependencyName,
                        vulnerability.DependencyVersion,
                        AffectedVersions = vulnerability.AffectedVersions != null 
                            ? JsonSerializer.Serialize(vulnerability.AffectedVersions, _jsonOptions)
                            : null,
                        vulnerability.Title,
                        vulnerability.Description,
                        Severity = vulnerability.Severity.ToString(),
                        vulnerability.CVSS,
                        vulnerability.CveId,
                        vulnerability.PublishedAt,
                        vulnerability.DiscoveredAt,
                        vulnerability.RemedialAction,
                        References = vulnerability.References != null 
                            ? JsonSerializer.Serialize(vulnerability.References, _jsonOptions)
                            : null,
                        AdditionalData = vulnerability.AdditionalData != null 
                            ? JsonSerializer.Serialize(vulnerability.AdditionalData, _jsonOptions)
                            : null
                    };
                    
                    await connection.ExecuteAsync(sql, parameters);
                    
                    _logger.LogInformation("Saved vulnerability {VulnerabilityId} for dependency {DependencyName}",
                        vulnerability.Id, vulnerability.DependencyName);
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error saving vulnerability {VulnerabilityId} for dependency {DependencyName}",
                    vulnerability.Id, vulnerability.DependencyName);
                throw;
            }
        }

        /// <summary>
        /// Saves a scan result
        /// </summary>
        public async Task SaveScanResultAsync(SecurityScanResult scanResult)
        {
            try
            {
                await _resiliencePolicy.ExecuteAsync(async () =>
                {
                    using var connection = new SqlConnection(_connectionString);
                    await connection.OpenAsync();
                    
                    // Ensure ID is set
                    if (string.IsNullOrEmpty(scanResult.Id))
                    {
                        scanResult.Id = Guid.NewGuid().ToString();
                    }
                    
                    // Count vulnerabilities by severity
                    var criticalCount = scanResult.Vulnerabilities?.Count(v => v.Severity == VulnerabilitySeverity.Critical) ?? 0;
                    var highCount = scanResult.Vulnerabilities?.Count(v => v.Severity == VulnerabilitySeverity.High) ?? 0;
                    var mediumCount = scanResult.Vulnerabilities?.Count(v => v.Severity == VulnerabilitySeverity.Medium) ?? 0;
                    var lowCount = scanResult.Vulnerabilities?.Count(v => v.Severity == VulnerabilitySeverity.Low) ?? 0;
                    
                    var sql = @"
                        INSERT INTO SecurityScans (
                            Id, ProjectPath, ScanType, ScanDate, VulnerabilityCount,
                            CriticalCount, HighCount, MediumCount, LowCount, ScanData
                        )
                        VALUES (
                            @Id, @ProjectPath, @ScanType, @ScanDate, @VulnerabilityCount,
                            @CriticalCount, @HighCount, @MediumCount, @LowCount, @ScanData
                        )";
                    
                    var parameters = new
                    {
                        scanResult.Id,
                        scanResult.ProjectPath,
                        ScanType = scanResult.ScanType.ToString(),
                        ScanDate = scanResult.ScanDate,
                        VulnerabilityCount = scanResult.Vulnerabilities?.Count ?? 0,
                        CriticalCount = criticalCount,
                        HighCount = highCount,
                        MediumCount = mediumCount,
                        LowCount = lowCount,
                        ScanData = JsonSerializer.Serialize(scanResult, _jsonOptions)
                    };
                    
                    await connection.ExecuteAsync(sql, parameters);
                    
                    _logger.LogInformation("Saved scan result for project {ProjectPath}", scanResult.ProjectPath);
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error saving scan result for project {ProjectPath}", scanResult.ProjectPath);
                throw;
            }
        }

        /// <summary>
        /// Gets the latest scan result for a project
        /// </summary>
        public async Task<SecurityScanResult> GetLatestScanResultAsync(string projectPath)
        {
            try
            {
                return await _resiliencePolicy.ExecuteAsync(async () =>
                {
                    using var connection = new SqlConnection(_connectionString);
                    await connection.OpenAsync();
                    
                    var sql = @"
                        SELECT TOP 1 ScanData
                        FROM SecurityScans
                        WHERE ProjectPath = @ProjectPath
                        ORDER BY ScanDate DESC";
                    
                    var scanData = await connection.QuerySingleOrDefaultAsync<string>(sql, new { ProjectPath = projectPath });
                    
                    if (string.IsNullOrEmpty(scanData))
                        return null;
                    
                    return JsonSerializer.Deserialize<SecurityScanResult>(scanData);
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting latest scan result for project {ProjectPath}", projectPath);
                return null;
            }
        }

        /// <summary>
        /// Gets all scan results for a project
        /// </summary>
        public async Task<List<SecurityScanResult>> GetScanHistoryAsync(string projectPath, int limit = 10)
        {
            try
            {
                return await _resiliencePolicy.ExecuteAsync(async () =>
                {
                    using var connection = new SqlConnection(_connectionString);
                    await connection.OpenAsync();
                    
                    var sql = @"
                        SELECT TOP (@Limit) ScanData
                        FROM SecurityScans
                        WHERE ProjectPath = @ProjectPath
                        ORDER BY ScanDate DESC";
                    
                    var scanDataList = await connection.QueryAsync<string>(sql, new { ProjectPath = projectPath, Limit = limit });
                    
                    var results = new List<SecurityScanResult>();
                    foreach (var scanData in scanDataList)
                    {
                        var scanResult = JsonSerializer.Deserialize<SecurityScanResult>(scanData);
                        if (scanResult != null)
                        {
                            results.Add(scanResult);
                        }
                    }
                    
                    return results;
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting scan history for project {ProjectPath}", projectPath);
                return new List<SecurityScanResult>();
            }
        }

        /// <summary>
        /// Checks if a version is affected by a vulnerability
        /// </summary>
        private bool IsVersionAffected(string version, List<string> affectedVersions)
        {
            if (affectedVersions == null || affectedVersions.Count == 0)
            {
                return false;
            }
            
            // Simple version matching for now
            return affectedVersions.Contains(version) || affectedVersions.Contains("*");
        }
        
        /// <summary>
        /// Maps database DTO to domain model
        /// </summary>
        private VulnerabilityInfo MapToVulnerabilityInfo(VulnerabilityDto dto)
        {
            var vulnerability = new VulnerabilityInfo
            {
                Id = dto.Id,
                DependencyName = dto.DependencyName,
                DependencyVersion = dto.DependencyVersion,
                Title = dto.Title,
                Description = dto.Description,
                CVSS = dto.CVSS,
                CveId = dto.CveId,
                PublishedAt = dto.PublishedAt,
                DiscoveredAt = dto.DiscoveredAt,
                RemedialAction = dto.RemedialAction
            };
            
            // Parse severity
            if (Enum.TryParse<VulnerabilitySeverity>(dto.Severity, out var severity))
            {
                vulnerability.Severity = severity;
            }
            
            // Deserialize affected versions
            if (!string.IsNullOrEmpty(dto.AffectedVersions))
            {
                vulnerability.AffectedVersions = JsonSerializer.Deserialize<List<string>>(dto.AffectedVersions);
            }
            
            // Deserialize references
            if (!string.IsNullOrEmpty(dto.References))
            {
                vulnerability.References = JsonSerializer.Deserialize<List<string>>(dto.References);
            }
            
            // Deserialize additional data
            if (!string.IsNullOrEmpty(dto.AdditionalData))
            {
                vulnerability.AdditionalData = JsonSerializer.Deserialize<Dictionary<string, object>>(dto.AdditionalData);
            }
            
            return vulnerability;
        }
        
        /// <summary>
        /// DTO for mapping database records
        /// </summary>
        private class VulnerabilityDto
        {
            public string Id { get; set; }
            public string DependencyName { get; set; }
            public string DependencyVersion { get; set; }
            public string AffectedVersions { get; set; }
            public string Title { get; set; }
            public string Description { get; set; }
            public string Severity { get; set; }
            public double? CVSS { get; set; }
            public string CveId { get; set; }
            public DateTime? PublishedAt { get; set; }
            public DateTime DiscoveredAt { get; set; }
            public string RemedialAction { get; set; }
            public string References { get; set; }
            public string AdditionalData { get; set; }
        }
    }
}